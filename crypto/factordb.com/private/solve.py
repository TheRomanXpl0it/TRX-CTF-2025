from collections import deque
from Crypto.Util.number import long_to_bytes

n = 48512240641840864698611285212880546891958282812678323164929695497979837667167371835079321738954614199887328209689700722900739026689495649897348371742808386272023319885638291436983171905959746612916786515990301081029893115996145232044829058978974408602308231813736063857659634459438506076453437963441215520733
e = 65537
c = 36547163254202175014719011914255607837474386170093760562818795855485895858656825454299902190817728613275689042837518944064285193789095094235166256812740012490802514031578972372211469389293445265540278842152695415520550436223647424764618861869589597420855316641231834238167223742740134122313062024294807514651
leak = 20826963965199127684756501660137785826786703139116744934461978331055754408584988351275721454251225474905754748284336808278049322016982012115699743632649066

F = lambda p,q: (0x1337 + p + q) ^ (0x1337 * p * q) & (p | 0x1337137)


print(bin(leak))


def bfs(n, leak):
    start = (0, 0, 1)
    queue = deque([start])
    ccc = 0
    while queue:
        pk, qk, k = queue.popleft()
        ccc += 1
        if ccc % 100 == 0:
            print(f"\r{k}",end='')
        if pk * qk > n:
            continue
        if pk * qk == n:
            print("FOUND", pk, qk)
            return pk, qk
        
        poss = [(0,0), (0,2**(k-1)), (2**(k-1),0), (2**(k-1),2**(k-1))]
        for pos in poss:
            if F(pk+pos[0], qk+pos[1]) % 2**k == leak%2**k and (pk+pos[0]) * (qk+pos[1]) % 2**k== n %2**k:
                new_state = (pk+pos[0], qk+pos[1], k+1)
                queue.append(new_state)

p,q = bfs(n, leak)
assert p*q == n
print(long_to_bytes(pow(c, pow(e, -1, (p-1)*(q-1)), n)))

# b'TRX{y0u_f0und_th3_pr1m3s!!}'